import sys
from dataclasses import asdict
from typing import Any, Optional, Type

from alembic.autogenerate import comparators, rewriter
from alembic.operations import ops
from pgvector.sqlalchemy import Vector
from sqlalchemy import ForeignKey, Integer, Text, text, MetaData, ForeignKeyConstraint, UniqueConstraint
from sqlalchemy.orm import DeclarativeBase, mapped_column, relationship, backref
from sqlalchemy.orm.decl_api import registry

from pgai.extensions.alembic.operations import EmbeddingConfig, ChunkingConfig, FormattingConfig, CreateVectorizerOp, \
    DropVectorizerOp


class EmbeddingBase(DeclarativeBase):
    """Base class for embedding models to prevent them from being auto-generated by Alembic"""
    pass

class VectorizerField:
    def __init__(
            self,
            source_column: str,
            model: str,
            dimensions: int = 1536,
            chunk_size: Optional[int] = None,
            chunk_overlap: Optional[int] = None,
            separator: Optional[str | list[str]] = None,
            formatting_template: Optional[str] = None,
            chat_user: Optional[str] = None,
            api_key_name: Optional[str] = None,
    ):
        self.embedding_config = EmbeddingConfig(
            model=model,
            dimensions=dimensions,
            chat_user=chat_user,
            api_key_name=api_key_name
        )

        self.chunking_config = ChunkingConfig(
            chunk_column=source_column,
            chunk_size=chunk_size,
            chunk_overlap=chunk_overlap,
            separator=separator
        )

        self.formatting_config = FormattingConfig(
            template=formatting_template or "$chunk"
        )

    def create_embedding_class(self, owner: type[DeclarativeBase]) -> type[DeclarativeBase]:
        table_name = f"{owner.__tablename__}_embedding_store"
        class_name = f"{owner.__name__}Embedding"
        registry_instance = owner.registry
        base = owner.__base__

        class Embedding(base):
        
            __tablename__ = table_name
            __table_args__ = {'info': {'pgai_managed': True}}
            registry = registry_instance

            embedding_uuid = mapped_column(Text, primary_key=True)
            id = mapped_column(Integer, ForeignKey(f"{owner.__tablename__}.id", ondelete="CASCADE"))
            chunk = mapped_column(Text, nullable=False)
            embedding = mapped_column(Vector(self.embedding_config.dimensions), nullable=False)
            chunk_seq = mapped_column(Integer, nullable=False)

        Embedding.__name__ = class_name
        return Embedding

    def __get__(self, obj, objtype=None):
        if obj is None:  # Class access
            return self._embedding_class
        # Instance access
        return getattr(obj, f"_{self.name}_relation")

    def __set_name__(self, owner, name):
        self.owner = owner
        self.name = name
        self._embedding_class = self.create_embedding_class(owner)

        # Set up relationship
        relationship_instance = relationship(
            self._embedding_class,
            foreign_keys=[self._embedding_class.id],
            backref=backref("parent", lazy="select"),
        )
        setattr(owner, f"_{name}_relation", relationship_instance)

        # Register vectorizer configuration
        if hasattr(owner, "registry") and owner.registry is not None:
            metadata = owner.registry.metadata
            self._register_with_metadata(metadata)
        elif hasattr(owner, "metadata"):
            self._register_with_metadata(owner.metadata)

    def _register_with_metadata(self, metadata: MetaData) -> None:
        """Register vectorizer configuration for migration generation"""
        if not hasattr(metadata, "info"):
            metadata.info = {}

        vectorizers = metadata.info.setdefault("vectorizers", {})
        vectorizers[f"{self.owner.__tablename__}.{self.name}"] = {
            "source_table": self.owner.__tablename__,
            "embedding": asdict(self.embedding_config),
            "chunking": asdict(self.chunking_config),
            "formatting": asdict(self.formatting_config),
        }


@comparators.dispatch_for("schema")
def compare_vectorizers(autogen_context, upgrade_ops, schemas):
    """Compare vectorizers between model and database."""

    print("Running vectorizer comparator!")  # Debug print

    conn = autogen_context.connection

    # Get all current vectorizers from database
    existing_vectorizers = set()
    for schema in schemas:
        result = conn.execute(text("""
            SELECT v.id, v.source_table 
            FROM ai.vectorizer v 
            WHERE split_part(v.source_table, '.', 1) = :schema
        """), {"schema": schema or "public"}).fetchall()

        for row in result:
            existing_vectorizers.add((row.source_table, row.id))

    # Get vectorizers from models
    model_vectorizers = set()
    if hasattr(autogen_context.metadata, "info"):
        vectorizers = autogen_context.metadata.info.get("vectorizers", {})
        for key, config in vectorizers.items():
            if "." in config["source_table"]:
                model_vectorizers.add(config["source_table"])
            else:
                # Add default schema if not specified
                model_vectorizers.add(f"public.{config['source_table']}")

    # Generate CreateVectorizerOp for new vectorizers
    for table_name in model_vectorizers.difference(v[0] for v in existing_vectorizers):
        # Find matching config
        for config in autogen_context.metadata.info["vectorizers"].values():
            if config["source_table"] == table_name or f"public.{config['source_table']}" == table_name:
                # Add CreateVectorizerOp to the upgrade operations
                upgrade_ops.ops.append(
                    CreateVectorizerOp(
                        config["source_table"],
                        embedding=EmbeddingConfig(**config["embedding"]),
                        chunking=ChunkingConfig(**config["chunking"]),
                        formatting=FormattingConfig(**config["formatting"])
                    )
                )
                break

    # Generate DropVectorizerOp for removed vectorizers 
    for table_name, vectorizer_id in existing_vectorizers:
        if table_name not in model_vectorizers:
            upgrade_ops.ops.append(
                DropVectorizerOp(vectorizer_id)
            )
     